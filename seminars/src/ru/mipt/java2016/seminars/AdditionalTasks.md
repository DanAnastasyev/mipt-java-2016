## Shell (0.5)
Реализуйте консольное приложение с возможностью отмены и повторения команд.
При реализации используйте [паттерн Команда](https://habrahabr.ru/post/114455/).

Список команд:
* ```cd <absolute path|relative path>``` &mdash; меняет
текущую директорию (поддерживаются ```.```, ```..```, относительные и абсолютные
пути)
* ```cp <source> <destination>``` &mdash; копирует указанную в параметрах
папку/файл в указанное место
* ```mv <source> <destination>``` &mdash; переносит указанный файл/папку в
новое место (файл на прежнем месте удаляется)
* ```mkdir <dirname>``` &mdash; создает директорию в текущей директории
* ```redo``` &mdash; повторяет последнее действие
* ```undo``` &mdash; отменяет последнее действие
* ```history``` &mdash; выводит историю действий
* ```exit``` &mdash; выходит из приложения

В должно отображаться "приглашение" &mdash; ```$ ``` (знак
доллара и пробел), после которого производится ввод команд. Ещё можно выводить текущую директорию перед приглашением.

## Stream API (0.5)
С помощью Stream API посчитайте количество вхождений каждого слова в [Вишневом саде](http://lib.ru/LITRA/CHEHOW/sad.txt). Чтение файла, его токенизация и подсчет слов должны быть реализованы одним запросом.

Тут будет интересно познакомиться с идеей MapReduce и адаптировать её к данной задаче.  
Стоит посмотреть объяснения [здесь](https://www.coursera.org/learn/hadoop/lecture/lgbWa/a-mapreduce-example-wordcount-in-detail) или [здесь](http://kickstarthadoop.blogspot.ru/2011/04/word-count-hadoop-map-reduce-example.html) (только ту часть, которая относится к объяснению идеи алгоритма).

Заметим, что stream'ы предоставляют нам функции с соответствующими названиями: `map` и `reduce`. Выглядит естественным использовать их в том же ключе. Только обратите внимание, что в stream'ах `reduce` один, в отличие от hadoop.  
Кроме того, возможно, проще будет пользовать не обычным `reduce`, а [`collect`](https://docs.oracle.com/javase/tutorial/collections/streams/reduction.html)

Для проверки подсчитайте то же самое с помощью обычного цикла.

## Proxy (0.5)
Проксирование с помощью java.lang.reflect.Proxy.

Необходимо написать реализацию интерфейса:
```java
public interface LoggingProxyFactory {
    Object wrap(
            Writer writer,
            Object implementation,
            Class<?> interfaceClass
    );
}
```

#### Формат отображения объектов
* Примитивные типы отображаются с помощью toString()
* Строки отображаются в двойных кавычках с экранированием управляющих символов
(т.е. эту строку можно будет вставить в исходный файл на Java)
* Перечисления (enum) отображатся с помощью name()
* Объекты отображаются в квадратных скобках как результат toString() с экранированием управляющих символов
* Массивы отображаются так: сначала длина массива, потом в фигурных скобках
элементы массива через запятую рекурсивно
* null отображается всегда строкой ```null```

#### Формат лога
Для метода из интерфейса List: ```int indexOf("abc")```:
```
List.indexOf("abc") returned -1
```

Для метода из интерфейса List: ```int indexOf(new Object())```:
```
List.indexOf([java.lang.Object@154ebadd]) returned 55
```

Для метода из интерфейса Collection: ```void clear()```:
```
Collection.clear();
```

Если метод выбросил исключение:
```
Collection.clear() threw java.lang.UnsupportedOperationException: Message
  at ru.fizteh.fivt.examples.Main.clear(Main.java:35)
  at ru.fizteh.fivt.examples.Main.main(Main.java:10)
```

Массив: ```void add(String[])```
```
Interface.add(2{"abc", "def"});
```

Если хотя бы один из параметров метода превышает 60 символов, то должна
использоваться расширенная запись:
```
MyInterface.method(
  [a very long result of toString() method of some object with huge amount of data],
  1,
  10
  )
  returned "abc"
```

В качестве отступа используется два пробела.

Написать юнит-тест для проверки работоспособности программы.

##### Дополнительно:
* Не надо проксировать вызовы методов, которые определены в Object. Как минимум это необходимо, чтобы не поломать симметричность поведения equals/hashCode.
* Если проксируемый метод выбрасывает исключение, то Method.invoke оборачивает его в исключение InvocationTargetException. Пробрасывать дальше надо targetException, а не обёртку.
* Proxy не имеет права выбрасывать "свои" исключения. При ошибке записи в Writer исключение должно быть проглочено.

## ThreadPool (0.5)
Напишите свою реализацию пулла потоков фиксированного размера - аналог [ExecutorService](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html).

Предлагается реализовывать следующий интерфейс:
```java
public interface ThreadPool {
    /**
     * Кладет задачу r в очередь на выполнение
     */
    void execute(Runnable r);
}
```

В реализации в конструкторе нужно задавать число потоков.

Поступающие задачи должны помещаться в очередь задач. Потоки должны выполнять задачи, пока эта очередь не опустеет. Если поток заканчивает со своей задачей, а новых задач нет - он засыпает в ожидании. Как только приходит новая задача, этот поток должен пробудиться, взять её из очереди и начать выполнять.

Как видно из интерфейса, достаточно реализовать обработку функций, которые ничего не принимают и ничего не возвращают.

[Пример реализации на C++](https://github.com/progschj/ThreadPool/blob/master/ThreadPool.h).

## Кэширование (0.5)
Реализовать механизм кэширования на `SoftReference`. Предлагается следующий интерфейс:
```java
public interface Cache<K,V> {
    /**
     * Возвращает соответствующее значение, если оно ещё в кэше, иначе null
     */
    V getIfPresent(Object key);

    /**
     * Сохраняет value по соответствующему ключу key 
     */
    void put(K key, V value);

    /**
     * Удаляет соответствующее ключу key значение
     */
    V remove(K key);

    /**
     * Очищает кэш
     */
    void clear();
}
```

В реализации нужно держать отображение из ключей в обернутые в `SoftReference` значения. Не нужно держать слишком долго ключи с вытесненными из памяти значениями - используйте [ReferenceQueue](https://docs.oracle.com/javase/7/docs/api/java/lang/ref/ReferenceQueue.html), чтобы обнаруживать пропавшие значения. Кроме того, нужно предотвращать вытеснение значений, к которым недавно обращались.

Напишите юнит-тест, проверяющий функциональность кэша.
